/*
    Arduino based EEPROM SPD reader and writer
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   For overclockers and PC hardware enthusiasts

   Repos:   https://github.com/1a2m3/SPD-Reader-Writer
   Support: https://forums.evga.com/FindPost/3053544
   Donate:  https://paypal.me/mik4rt3m

   PS: DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
   CONFIGURABLE SETTINGS ARE IN "SpdReaderWriterSettings.h" FILE

*/

#include <Wire.h>
#include "SpdReaderWriterSettings.h" // Settings

#define VERSION 20210321 // Version number (YYYYMMDD)

// EEPROM page commands
#define SPA0 0x6C   // Set EE Page Address to 0 (addresses  00h to  FFh) (  0-255) (DDR4)
#define SPA1 0x6E   // Set EE Page Address to 1 (addresses 100h to 1FFh) (256-511) (DDR4)
#define RPA  0x6D   // Read EE Page Address                                        (DDR4)

// EEPROM RSWP commands
#define RPS0 0x63   // Read SWP0 status         (addresses  00h to  7Fh) (  0-127) (DDR4/DDR3/DDR2)
#define RPS1 0x69   // Read SWP1 status         (addresses  80h to  FFh) (128-255) (DDR4)
#define RPS2 0x6B   // Read SWP2 status         (addresses 100h to 17Fh) (256-383) (DDR4)
#define RPS3 0x61   // Read SWP3 status         (addresses 180h to 1FFh) (384-511) (DDR4)

#define SWP0 0x62   // Set RSWP for block 0     (addresses  00h to  7Fh) (  0-127) (DDR4/DDR3/DDR2)
#define SWP1 0x68   // Set RSWP for block 1     (addresses  80h to  FFh) (128-255) (DDR4)
#define SWP2 0x6A   // Set RSWP for block 2     (addresses 100h to 17Fh) (256-383) (DDR4)
#define SWP3 0x60   // Set RSWP for block 3     (addresses 180h to 1FFh) (384-511) (DDR4)

#define CWP  0x66   // Clear RSWP                                                  (DDR4/DDR3/DDR2)

// EEPROM PSWP commands
#define PWPB 0b0110 // PSWP Device Type Identifier Control Code (bits 7-4)

// EEPROM data
#define DNC  0x00   // "Do not care" byte

// Device commands
#define READBYTE          'r' // [R]ead
#define WRITEBYTE         'w' // [W]rite
#define SCANBUS           's' // [S]can I2C bus
#define PROBEADDRESS      'a' // [A]ddress test
#define SETADDRESSPIN     'p' // [P]in control
#define GETADDRESSPIN     'q' // [Q]uery pin state
#define SETHVSTATE        '9' // [9]V control
#define GETHVSTATE        'h' // [H]igh voltage status
#define SETREVERSIBLESWP  'b' // [B]lock
#define GETREVERSIBLESWP  'o' // [O]btain RSWP status
#define CLEARSWP          'c' // [C]lear RSWP
#define SETPERMANENTSWP   'l' // [L]ock
#define GETPSWP           'u' // [U]nwritable?
#define GETVERSION        'v' // [V]ersion
#define TEST              't' // [T]est

// Device responses
#define SUCCESS (byte)  0
#define ERROR   (byte)  1
#define ZERO    (byte)  0   // Used to indicate an error where a numeric non-zero answer is normally expected
#define WELCOME (byte) '!'

// Pin states
#define ON  HIGH
#define OFF LOW

// Global variables
int eepromPageAddress = 0;   // Initial EEPROM page address
int pins[] = { SA0SW, SA1SW, SA2SW }; // SA pins array

void setup() {

  // SA controls
  pinMode(SA0SW, OUTPUT);
  pinMode(SA1SW, OUTPUT);
  pinMode(SA2SW, OUTPUT);

  // HV controls
  pinMode(HVSW,  OUTPUT);
  pinMode(HVDET,  INPUT);

  // Initiate and join the I2C bus as a master
  Wire.begin();
  // Set I2C clock frequency
  Wire.setClock(I2CCLOCK);

  // Reset EEPROM page address
  setPageAddress(0);

  // Reset SA pins configuration
  setAddressPin(SA0SW, OFF);
  setAddressPin(SA1SW, OFF);
  setAddressPin(SA2SW, OFF);

  // Reset HV state
  setHighVoltage(OFF);

  PORT.begin(BAUD_RATE);
  PORT.setTimeout(1000); // 1 sec. timeout

  // Wait for serial monitor
  while (!PORT) {}

  PORT.write(WELCOME);
}

void loop() {
  // Wait for input data
  while (!PORT.available()) {}

  // Process input commands and data
  parseCommand();

  // Clear port buffer
  PORT.flush();
}

// Process input commands and data
void parseCommand() {
  if (!PORT.available()) {
    return;
  }

  char cmd = PORT.read();

  switch (cmd) {

    // Read byte
    case READBYTE: cmdRead();
      break;

    // Write byte
    case WRITEBYTE: cmdWrite();
      break;

    // Scan i2c bus for addresses
    case SCANBUS: cmdScanBus();
      break;

    // Probe if i2c address is valid
    case PROBEADDRESS: cmdProbeBusAddress();
      break;

    // Set EEPROM SA pin state
    case SETADDRESSPIN: cmdSetAddressPin();
      break;

    // Get EEPROM SA pin state
    case GETADDRESSPIN: cmdGetAddressPin();
      break;

    // Control High Voltage supply
    case SETHVSTATE: cmdSetHighVoltage();
      break;

    // Get High Voltage supply state
    case GETHVSTATE: cmdGetHighVoltage();
      break;

    // Enable RSWP
    case SETREVERSIBLESWP: cmdEnableRSWP();
      break;

    // Clear RSWP
    case CLEARSWP: cmdClearRSWP();
      break;

    // Read SWP status
    case GETREVERSIBLESWP: cmdReadRSWP();
      break;

    // Enable PSWP
    case SETPERMANENTSWP: cmdEnablePSWP();
      break;

    // Read permanent write protection status
    case GETPSWP: cmdReadPSWP();
      break;

    // Get Firmware version
    case GETVERSION: cmdVersion();
      break;

    // Device Communication Test
    case TEST: cmdTest();
      break;
  }
}

/*  -=  Command handlers  =-  */

void cmdRead() {
  int address = PORT.parseInt(); // EEPROM address
  int offset  = PORT.parseInt(); // Offset address
  int count   = PORT.parseInt(); // Byte count
  
  for (int i = 0; i < count; i++) {
    PORT.write(readByte(address, offset + i));
  }
}

void cmdWrite() {
  int address = PORT.parseInt(); // EEPROM address
  int offset  = PORT.parseInt(); // Offset address
  byte data   = PORT.parseInt(); // Byte value

  PORT.write(writeByte(address, offset, data) ? SUCCESS : ERROR);
}

void cmdScanBus() {

  byte response = NULL;

  for (int i = 0; i <= 8; i++) {
    if (probeBusAddress(i + 80)) {
      response |= ((byte)1 << i);
    }
  }
  PORT.write(response);
}

void cmdTest() {
  PORT.write(WELCOME);
}

void cmdVersion() {
  PORT.print(VERSION);
}

void cmdProbeBusAddress() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(probeBusAddress(address) ? SUCCESS : ERROR);
}

void cmdClearRSWP() {
  PORT.write(clearWriteProtection() ? SUCCESS : ERROR);
}

void cmdEnableRSWP() {
  int block = PORT.parseInt(); // Block number
  PORT.write(setWriteProtection(block) ? SUCCESS : ERROR);
}

void cmdReadRSWP() {
  int block = PORT.parseInt(); // Block number
  PORT.write(readWriteProtection(block) ? SUCCESS : ERROR);
}

void cmdEnablePSWP() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(setPermanentWriteProtection(address) ? SUCCESS : ERROR);
}

void cmdReadPSWP() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(readPermanentWriteProtection(address) ? SUCCESS : ERROR);
}

void cmdSetAddressPin() {
  int  addressPin      = PORT.parseInt(); // SA pin number
  bool addressPinState = PORT.parseInt(); // SA pin state

  int pin = (addressPin >= 0 || addressPin <= 2) ? pins[addressPin] : pins[1];

  setAddressPin(pin, addressPinState);

  PORT.write(digitalRead(pin) == addressPinState ? SUCCESS : ERROR);
}

void cmdGetAddressPin() {
  int addressPin = PORT.parseInt(); // SA pin number
  int pin = (addressPin >= 0 || addressPin <= 2) ? pins[addressPin] : pins[1];

  PORT.write(getAddressPin(pin) == ON ? ON : OFF);
}

void cmdSetHighVoltage() {
  bool state = (bool)PORT.parseInt();
  PORT.write(setHighVoltage(state) ? SUCCESS : ERROR);
}

void cmdGetHighVoltage() {
  PORT.write(getHighVoltage() ? ON : OFF);
}


/*  -=  Read/Write functions  =-  */

// Reads a byte
byte readByte(uint8_t deviceAddress, uint16_t offset) {

  adjustPageAddress(offset);

  Wire.beginTransmission(deviceAddress);
  Wire.write((uint8_t)(offset & 0xFF));
  Wire.endTransmission();
  Wire.requestFrom(deviceAddress, (uint8_t)1);

  while (!Wire.available()) {}
  return Wire.read();
}

// Writes a byte
bool writeByte(uint8_t deviceAddress, uint16_t offset, byte data) {

  adjustPageAddress(offset);

  Wire.beginTransmission(deviceAddress);
  Wire.write((uint8_t)(offset & 0xFF));
  Wire.write(data);
  int status = Wire.endTransmission();

  delay(10);

  return status == 0; // TODO: writing to PSWP-protected area returns true
}


/*  -=  RSWP functions  =-  */

// Sets reversible write protection on specified block
bool setWriteProtection(uint8_t block) {

  int commands[] = { SWP0, SWP1, SWP2, SWP3 };
  int cmd = (block > 0 || block <= 3) ? commands[block] : commands[0];

  setHighVoltage(ON);
  bool result = probeDeviceTypeId(cmd);
  setHighVoltage(OFF);

  return result;
}

// Reads reversible write protection status
bool readWriteProtection(uint8_t block) {

  int commands[] = { RPS0, RPS1, RPS2, RPS3 };
  int cmd = (block > 0 || block <= 3) ? commands[block] : commands[0];

  setHighVoltage(OFF);

  return probeDeviceTypeId(cmd); // true = unprotected; false = protected or rswp not supported
}

// Clears reversible software write protection
bool clearWriteProtection() {

  setHighVoltage(ON);
  bool result = probeDeviceTypeId(CWP);
  setHighVoltage(OFF);

  return result;
}


/*  -=  High Voltage (9V) functions  =-  */

// Controls HV source (set state to ON to turn on, or OFF to turn off)
bool setHighVoltage(bool state) {

  // Disconnect SA0 from VCC before applying HV to it
  if (state == ON) {
    setAddressPin(SA0SW, OFF);
  }
  digitalWrite(HVSW, state);
  delay(state == ON ? 25 : 0);

  // Return operation result
  return getHighVoltage() == state;
}

// Returns HV status by reading HVDET
bool getHighVoltage() {
  return digitalRead(HVDET);
}


/*  -=  PSWP functions  =-  */

// Sets permanent write protection on supported EEPROMs
bool setPermanentWriteProtection(uint8_t deviceAddress) {

  // Keep address bits (SA0-SA2) intact and change bits 7-4 to '0110'
  uint8_t cmd = (deviceAddress & 0b111) | (PWPB << 3);

  Wire.beginTransmission(cmd);
  // Write 2 DNC bytes to force LSB to set to 0
  Wire.write(DNC);
  Wire.write(DNC);
  int status = Wire.endTransmission();
  delay(10);

  return status == 0;

  //uint8_t cmd = (deviceAddress & 0b111) << 1 | (PWPB << 4);
  //return probeDeviceTypeId(cmd << 1);
}

// Read permanent write protection status
bool readPermanentWriteProtection(uint8_t deviceAddress) {

  // Keep address bits (SA0-SA2) intact and change bits 7-4 to '0110'
  uint8_t cmd = (deviceAddress & 0b111) | (PWPB << 3);

  Wire.beginTransmission(cmd);
  // Write 1 DNC byte to force LSB to set to 1
  Wire.write(DNC);
  int status = Wire.endTransmission();
  delay(10);

  return status == 0; // returns true if PSWP is not set

  //uint8_t cmd = (deviceAddress & 0b111) << 1 | (PWPB << 4);
  //return probeDeviceTypeId(cmd << 1 | 1);
}


/*  -=  EEPROM Page functions  =-  */

// Get currently selected page address
int getPageAddress() {
  //return probeDeviceTypeId(RPA) ? 0 : 1; // slow
  return eepromPageAddress;
}

// Sets page address to access lower or upper 256 bytes of DDR4 SPD
void setPageAddress(uint8_t pageNumber) {

  int cmd = (pageNumber == 0) ? SPA0 : SPA1;
  probeDeviceTypeId(cmd);
  eepromPageAddress = cmd >> 1 & 1;
}

// Adjusts page address according to byte offset specified
void adjustPageAddress(uint16_t offset) {

  if (offset <= 0xFF && getPageAddress() != 0) {
    setPageAddress(0);
  }
  if (offset > 0xFF  && getPageAddress() != 1) {
    setPageAddress(1);
  }
}


/*  -=  I2C bus functions  =-  */

// Control slave address pins
bool setAddressPin(int pin, bool state) {

  // Turn off HV when SA0 is being configured while HV is applied to it
  if (pin == SA0SW && getHighVoltage() == ON) {
    setHighVoltage(OFF);
  }
  digitalWrite(pin, state);
  delay(1);

  return digitalRead(pin) == state;
}

// Get slave address pin state
bool getAddressPin(int pin) {
  return digitalRead(pin);
}

// Tests if device address is present on I2C bus
bool probeBusAddress(uint8_t address) {
  Wire.beginTransmission(address);
  return Wire.endTransmission() == 0;
}

// Tests if device select code returns ACK
bool probeDeviceTypeId(uint8_t deviceSelectCode) {

  // Wire library uses 7 bit address, so we strip the LSB from the DSC by bitshifting right by 1
  int cmd = deviceSelectCode >> 1;

  // Check the LSB of DSC, if it is 0 (write), then we need to write DNC address + DNC data
  bool writeBit = (deviceSelectCode & 1) == 0;

  Wire.beginTransmission(cmd);
  if (writeBit) {
    Wire.write(DNC);
    Wire.write(DNC);
  }
  int status = Wire.endTransmission();

  if (writeBit) {
    return status == 0;
  }
  else {
    Wire.requestFrom(cmd, 1);
    return Wire.available() > 0; // true when ACK is received after control byte
  }
}
