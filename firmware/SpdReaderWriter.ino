/*
    Arduino based EEPROM SPD reader and writer
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   For overclockers and PC hardware enthusiasts

   Repos:   https://github.com/1a2m3/SPD-Reader-Writer
   Support: https://forums.evga.com/FindPost/3053544
   Donate:  https://paypal.me/mik4rt3m

   PS: DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
   CONFIGURABLE SETTINGS ARE IN "SpdReaderWriterSettings.h" FILE

*/

#define VERSION 20200815 // Version number (YYYYMMDD)

#include <Wire.h>
#include "SpdReaderWriterSettings.h" // Settings

// EEPROM page commands
#define SPA0 0x36   // Set EE Page Address to 0 (addresses  00h to  FFh) (  0-255) (DDR4)
#define SPA1 0x37   // Set EE Page Address to 1 (addresses 100h to 1FFh) (256-511) (DDR4)

// EEPROM RSWP commands
#define SWP0 0x31   // Set RSWP for block 0     (addresses  00h to  7Fh) (  0-127) (DDR4/DDR3/DDR2)
#define SWP1 0x34   // Set RSWP for block 1     (addresses  80h to  FFh) (128-255) (DDR4)
#define SWP2 0x35   // Set RSWP for block 2     (addresses 100h to 17Fh) (256-383) (DDR4)
#define SWP3 0x30   // Set RSWP for block 3     (addresses 180h to 1FFh) (384-511) (DDR4)
#define CWP  0x33   // Clear RSWP                                                  (DDR4/DDR3/DDR2)

// EEPROM PSWP commands
#define PWPB 0b0110 // PSWP Device Type Identifier Code (bits 7-4)

// EEPROM data
#define DNC  0x00   // "Do not care" byte

// Device commands
#define READBYTE          'r' // [R]ead
#define WRITEBYTE         'w' // [W]rite
#define SCANBUS           's' // [S]can I2C bus
#define PROBEADDRESS      'a' // [A]ddress test
#define SETADDRESSPIN     'p' // [P]in control
#define SETHVSTATE        '9' // [9]V control
#define GETHVSTATE        'h' // [H]igh voltage status
#define SETREVERSIBELSWP  'b' // [B]lock
#define CLEARSWP          'c' // [C]lear
#define SETPERMANENTSWP   'l' // [L]ock
#define GETPSWP           'u' // [U]nwritable?
#define GETVERSION        'v' // [V]ersion
#define TEST              't' // [T]est

// Device responses
#define SUCCESS (byte)  0
#define ERROR   (byte)  1
#define NULL    (byte)  0   // Used to indicate an error where a numeric non-zero answer is normally expected
#define WELCOME (byte) '!'

// Pin states
#define ON  HIGH
#define OFF LOW

// Global variables
int eepromPageAddress = 0;   // Initial EEPROM page address

void setup() {

  // SA controls
  pinMode(SA0SW, OUTPUT);
  pinMode(SA1SW, OUTPUT);
  pinMode(SA2SW, OUTPUT);

  // HV controls
  pinMode(HVSW,  OUTPUT);
  pinMode(HVDET,  INPUT);

  // Initiate and join the I2C bus as a master
  Wire.begin();

  // Reset EEPROM page address
  setPageAddress(eepromPageAddress);

  // Reset SA pins configuration
  setAddressPin(SA0SW, OFF);
  setAddressPin(SA1SW, OFF);
  setAddressPin(SA2SW, OFF);

  // Reset HV state
  setHighVoltage(OFF);

  PORT.begin(BAUD_RATE);
  PORT.setTimeout(1000); // 1 sec. timeout

  // Wait for serial monitor
  while (!PORT) {}
  
  PORT.write(WELCOME);
}

// Controls HV source (set state to ON to turn on, or OFF to turn off)
bool setHighVoltage(bool state) {

  // Disconnect SA0 from VCC before applying HV to it
  if (state == ON) {
    setAddressPin(SA0SW, OFF);
  }
  digitalWrite(HVSW, state);
  delay(10);

  // Return operation result
  return getHighVoltage() == state;
}

// Returns HV status by reading HVDET
bool getHighVoltage() {
  return digitalRead(HVDET);
}

// Turns on or off select address pins
bool setAddressPin(int pin, bool state) {

  // Turn off HV when SA0 is being configured while HV is applied to it
  if (pin == SA0SW && getHighVoltage() == ON) {
    setHighVoltage(OFF);
  }
  digitalWrite(pin, state);
  delay(10);

  return digitalRead(pin) == state;
}

// Clears reversible software write protection
bool clearWriteProtection() {

  setHighVoltage(ON);

  Wire.beginTransmission(CWP);
  Wire.write(DNC);
  Wire.write(DNC);
  int status = Wire.endTransmission();

  setHighVoltage(OFF);

  return status == 0;
}

// Sets reversible write protection on specified block
bool setWriteProtection(uint8_t block) {

  int commands[] = { SWP0, SWP1, SWP2, SWP3 };
  int cmd = (block >= 0 || block <= 3) ? commands[block] : commands[0];

  setHighVoltage(ON);

  Wire.beginTransmission(cmd);
  Wire.write(DNC);
  Wire.write(DNC);
  int status = Wire.endTransmission(); // status == 0 when SWP is enabled

  setHighVoltage(OFF);

  return status == 0;
}

// Sets permanent write protection on supported EEPROMs
bool setPermanentWriteProtection(uint8_t deviceAddress) {

  uint8_t cmd = (deviceAddress & 0b111) + (PWPB << 3); // Keep address bits (SA0-SA2) intact and change bits 7-4 to '0110'

  Wire.beginTransmission(cmd);
  Wire.write(DNC);
  Wire.write(DNC);
  int status = Wire.endTransmission();
  delay(10);

  return status == 0;
}

// Read permanent write protection status
bool readPermanentWriteProtection(uint8_t deviceAddress) {

  // Keep address bits (SA0-SA2) intact and change bits 7-4 to '0110'
  uint8_t cmd = (deviceAddress & 0b111) + (PWPB << 3);

  Wire.beginTransmission(cmd);
  Wire.write(DNC);
  int status = Wire.endTransmission();
  delay(10);

  return status == 0; // returns true if PSWP is not set
}

// Reads a byte
byte readByte(uint8_t deviceAddress, uint16_t offset) {

  adjustPageAddress(offset);

  Wire.beginTransmission(deviceAddress);
  Wire.write(offset);
  Wire.endTransmission();
  Wire.requestFrom(deviceAddress, (uint8_t)1);

  while(!Wire.available()) {}
  return Wire.read();
}

// Writes a byte
bool writeByte(uint8_t deviceAddress, uint16_t offset, byte data) {

  adjustPageAddress(offset);

  Wire.beginTransmission(deviceAddress);
  Wire.write(offset);
  Wire.write(data);
  int status = Wire.endTransmission();

  delay(10);

  //return status == 0; // TODO: writing to PSWP-protected area returns true
  return status == 0 && readByte(deviceAddress, offset) == data;
}

// Sets page address to access lower or upper 256 bytes of DDR4 SPD
void setPageAddress(uint8_t pageNumber) {
  Wire.beginTransmission((pageNumber == 0) ? SPA0 : SPA1);
  Wire.endTransmission();

  eepromPageAddress = pageNumber;
}

// Get currently selected page address
int getPageAddress() {
  return eepromPageAddress;
}

// Adjusts page address according to byte offset specified
void adjustPageAddress(uint16_t offset) {
  if (offset <= 0xFF && getPageAddress() != 0) {
    setPageAddress(0);
  }
  if (offset > 0xFF  && getPageAddress() != 1) {
    setPageAddress(1);
  }
}

// Tests if device address is present on I2C bus
bool probeAddress(uint8_t address) {
  Wire.beginTransmission(address);
  return Wire.endTransmission() == 0;
}

/*  -=  Command handlers  =-  */

void cmdScan() {
  int startAddress = PORT.parseInt(); // First EEPROM address
  int endAddress   = PORT.parseInt(); // Last EEPROM address

  if (startAddress > endAddress) {
    PORT.write(NULL); // Return 0 when start and end addresses are incorrectly specified
    return;
  }

  for (int i = startAddress; i <= endAddress; i++) {
    PORT.write(probeAddress(i) ? i : NULL); // Return 0 to prevent application from waiting in case no devices are present
  }
}

void cmdRead() {
  int address = PORT.parseInt(); // EEPROM address
  int offset  = PORT.parseInt(); // Offset address
  PORT.write(readByte(address, offset));
}

void cmdWrite() {
  int address = PORT.parseInt(); // EEPROM address
  int offset  = PORT.parseInt(); // Offset address
  byte data   = PORT.parseInt(); // Byte value

  PORT.write(writeByte(address, offset, data) ? SUCCESS : ERROR);
}

void cmdTest() {
  PORT.write(WELCOME);
}

void cmdProbeAddress() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(probeAddress(address) ? address : NULL);  
}

void cmdClearRSWP() {
  PORT.write(clearWriteProtection() ? SUCCESS : ERROR);
}

void cmdEnableRSWP() {
  int block = PORT.parseInt(); // Block number
  block = (block >= 0 && block <= 3) ? block : 0; // Block number can't be outside of 0-3 range

  PORT.write(setWriteProtection(block) ? SUCCESS : ERROR);  
}

void cmdEnablePSWP() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(setPermanentWriteProtection(address) ? SUCCESS : ERROR);
}

void cmdReadPSWP() {
  int address = PORT.parseInt(); // EEPROM address
  PORT.write(readPermanentWriteProtection(address) ? SUCCESS : ERROR);  
}

void cmdSetAddressPin() {
  int  addressPin      = PORT.parseInt(); // SA pin number
  bool addressPinState = PORT.parseInt(); // SA pin state
  int  pin;

  switch (addressPin) {
    case 0: pin = SA0SW;
      break;
    case 1: pin = SA1SW;
      break;
    case 2: pin = SA2SW;
      break;
    default: pin = SA1SW;
      break;
  }

  setAddressPin(pin, addressPinState);

  PORT.write(digitalRead(pin) == addressPinState ? SUCCESS : ERROR);  
}

void cmdSetHighVoltage() {
  bool state = (bool)PORT.parseInt();
  PORT.write(setHighVoltage(state) ? SUCCESS : ERROR);
}

void cmdGetHighVoltage() {
  PORT.write(getHighVoltage() ? ON : OFF);
}

void cmdVersion() {
  PORT.print(VERSION);
}

void parseCommand() {
  if (!PORT.available()) {
    return;
  }

  char cmd = PORT.read();

  switch (cmd) {

    // Read byte
    case READBYTE: cmdRead();
      break;

    // Write byte
    case WRITEBYTE: cmdWrite();
      break;

    // Scan i2c bus for addresses
    case SCANBUS: cmdScan();
      break;

    // Probe if i2c address is valid
    case PROBEADDRESS: cmdProbeAddress();
      break;

    // Set EEPROM SA pin state
    case SETADDRESSPIN: cmdSetAddressPin();
      break;

    // Control High Voltage supply
    case SETHVSTATE: cmdSetHighVoltage();
      break;

    // Get High Voltage supply state
    case GETHVSTATE: cmdGetHighVoltage();
      break;

    // Enable RSWP
    case SETREVERSIBELSWP: cmdEnableRSWP();
      break;

    // Clear RSWP
    case CLEARSWP: cmdClearRSWP();
      break;

    // Enable PSWP
    case SETPERMANENTSWP: cmdEnablePSWP();
      break;

    // Read permanent write protection status
    case GETPSWP: cmdReadPSWP();
      break;

    // Get Firmware version
    case GETVERSION: cmdVersion();
      break;

    // Device Communication Test
    case TEST: cmdTest();
      break;
  }
}

void loop() {
  // Wait for input data
  while (!PORT.available()) {}

  // Process input commands and data
  parseCommand();

  // Clear port buffer
  PORT.flush();
}
